generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id @default(cuid())
  email          String          @unique
  name           String?
  firstName      String?         @map("firstName")
  lastName       String?         @map("lastName")
  image          String?
  passwordHash   String?
  role           Role            @default(CAPTAIN)
  emailVerified  DateTime?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  captainProfile CaptainProfile?
  verification   CaptainVerification?
  accounts       Account[]
  sessions       Session[]
  drafts         CharterDraft[]
  notesAuthored  DraftNote[]     @relation("UserDraftNotes")
}

model CaptainProfile {
  id            String    @id @default(cuid())
  userId        String    @unique
  firstName     String
  lastName      String
  displayName   String
  phone         String
  bio           String
  experienceYrs Int       @default(0)
  avatarUrl     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  user          User      @relation(fields: [userId], references: [id])
  charters      Charter[]
}

model Charter {
  id            String             @id @default(cuid())
  captainId     String
  charterType   String
  name          String
  state         String
  city          String
  startingPoint String
  postcode      String
  latitude      Decimal?           @db.Decimal(10, 7)
  longitude     Decimal?           @db.Decimal(10, 7)
  description   String
  pricingPlan   CharterPricingPlan @default(BASIC)
  boatId        String?            @unique
  isActive      Boolean            @default(true)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  boat          Boat?              @relation(fields: [boatId], references: [id])
  captain       CaptainProfile     @relation(fields: [captainId], references: [id])
  amenities     CharterAmenity[]
  features      CharterFeature[]
  media         CharterMedia[]
  pickup        Pickup?
  policies      Policies?
  trips         Trip[]
  draft         CharterDraft?
  backupPhone   String?
}

model Boat {
  id        String   @id @default(cuid())
  name      String
  type      String
  lengthFt  Int
  capacity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  charter   Charter?
}

model Pickup {
  id        String       @id @default(cuid())
  charterId String       @unique
  available Boolean      @default(false)
  fee       Decimal?     @db.Decimal(10, 2)
  notes     String?
  charter   Charter      @relation(fields: [charterId], references: [id])
  areas     PickupArea[]
}

model PickupArea {
  id       String @id @default(cuid())
  pickupId String
  label    String
  pickup   Pickup @relation(fields: [pickupId], references: [id])
}

model Policies {
  id               String  @id @default(cuid())
  charterId        String  @unique
  licenseProvided  Boolean
  catchAndKeep     Boolean
  catchAndRelease  Boolean
  childFriendly    Boolean
  liveBaitProvided Boolean
  alcoholNotAllowed   Boolean
  smokingNotAllowed   Boolean
  charter          Charter @relation(fields: [charterId], references: [id])
}

model CharterAmenity {
  id        String  @id @default(cuid())
  charterId String
  label     String
  charter   Charter @relation(fields: [charterId], references: [id])
}

model CharterFeature {
  id        String  @id @default(cuid())
  charterId String
  label     String
  charter   Charter @relation(fields: [charterId], references: [id])
}

model CharterMedia {
  id         String    @id @default(cuid())
  charterId  String
  tripId     String?
  kind       MediaKind
  url        String
  storageKey String
  mimeType   String?
  sizeBytes  Int?
  width      Int?
  height     Int?
  // Optional persisted thumbnail for videos (or generated image variants)
  thumbnailUrl String? @map("thumbnail_url")
  // Basic video metadata (duration in seconds) if available
  durationSeconds Int? @map("duration_seconds")
  sortOrder  Int       @default(0)
  createdAt  DateTime  @default(now())
  charter    Charter   @relation(fields: [charterId], references: [id])
  trip       Trip?     @relation(fields: [tripId], references: [id])
  // Link back to PendingMedia once consumed (optional)
  pendingMediaId String?   @unique
  pendingMedia   PendingMedia? @relation("PendingToCharter", fields: [pendingMediaId], references: [id])
}

// --------------------------------------
// Drafts (Phase 1 incremental submission)
// --------------------------------------

model CharterDraft {
  id            String      @id @default(cuid())
  userId        String
  status        DraftStatus @default(DRAFT)
  currentStep   Int         @default(0)
  formVersion   Int         @default(1)
  data          Json
  version       Int         @default(1)
  charterId     String?     @unique
  lastTouchedAt DateTime    @default(now())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  user          User        @relation(fields: [userId], references: [id])
  charter       Charter?    @relation(fields: [charterId], references: [id])
  notes         DraftNote[]
  @@index([lastTouchedAt])
}

enum DraftStatus {
  DRAFT
  SUBMITTED
  ABANDONED
  DELETED
}

// --------------------------------------
// NextAuth adapter models
// --------------------------------------

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Trip {
  id            String          @id @default(cuid())
  charterId     String
  name          String
  tripType      String
  price         Decimal         @db.Decimal(10, 2)
  durationHours Int
  maxAnglers    Int
  style         CharterStyle
  description   String?
  promoPrice    Decimal? @db.Decimal(10, 2)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  media         CharterMedia[]
  charter       Charter         @relation(fields: [charterId], references: [id])
  species       TripSpecies[]
  startTimes    TripStartTime[]
  techniques    TripTechnique[]
}

model TripStartTime {
  id     String @id @default(cuid())
  tripId String
  value  String
  trip   Trip   @relation(fields: [tripId], references: [id])
}

model TripSpecies {
  id     String @id @default(cuid())
  tripId String
  value  String
  trip   Trip   @relation(fields: [tripId], references: [id])
}

model TripTechnique {
  id     String @id @default(cuid())
  tripId String
  value  String
  trip   Trip   @relation(fields: [tripId], references: [id])
}

enum CharterPricingPlan {
  BASIC
  SILVER
  GOLD
}

enum CharterStyle {
  PRIVATE
  SHARED
}

enum MediaKind {
  CHARTER_PHOTO
  CHARTER_VIDEO
  CAPTAIN_AVATAR
  TRIP_MEDIA
}

// --------------------------------------
// Pending Media (staging before charter association)
// --------------------------------------

enum PendingMediaStatus {
  QUEUED       // video queued for transcode OR image queued for optional transform
  TRANSCODING  // worker actively processing (video)
  READY        // final asset (image or transcoded video) available
  FAILED       // processing failed; error field populated
}

model PendingMedia {
  id              String             @id @default(cuid())
  userId          String
  charterId       String?            // becomes non-null when attached (editing or after finalize)
  kind            String             // "IMAGE" | "VIDEO" (string for forward compatibility)
  originalKey     String
  originalUrl     String
  finalKey        String?
  finalUrl        String?
  thumbnailKey    String?
  thumbnailUrl    String?
  status          PendingMediaStatus
  sizeBytes       Int?
  mimeType        String?
  width           Int?
  height          Int?
  durationSeconds Int?
  error           String?
  correlationId   String?
  consumedAt      DateTime?
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  // Optional linkage once consumed
  charterMediaId  String?            @unique
  charterMedia    CharterMedia?      @relation("PendingToCharter")

  @@index([userId, status])
  @@index([charterId])
  @@index([createdAt])
}

// --------------------------------------
// Roles
// --------------------------------------

enum Role {
  CAPTAIN
  STAFF
  ADMIN
}

// --------------------------------------
// Captain Verification (documents)
// --------------------------------------

model CaptainVerification {
  id               String               @id @default(cuid())
  userId           String               @unique
  idFront          Json?
  idBack           Json?
  captainLicense   Json?
  boatRegistration Json?
  fishingLicense   Json?
  additional       Json                 @default("[]") // JSON array of Uploaded
  status           VerificationStatus   @default(PENDING)
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  user             User                 @relation(fields: [userId], references: [id])
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

// --------------------------------------
// Staff draft notes
// --------------------------------------

model DraftNote {
  id        String      @id @default(cuid())
  draftId   String
  authorId  String
  body      String
  createdAt DateTime    @default(now())
  draft     CharterDraft @relation(fields: [draftId], references: [id])
  author    User         @relation("UserDraftNotes", fields: [authorId], references: [id])
  @@index([draftId])
  @@index([authorId])
}

// --------------------------------------
// Audit Logging
// --------------------------------------

model AuditLog {
  id            String   @id @default(cuid())
  actorUserId   String
  entityType    String   // e.g. 'charter','boat','trip','captainProfile'
  entityId      String
  action        String   // e.g. 'update','create','delete'
  before        Json?
  after         Json?
  changed       Json?    // list or map of changed field paths
  correlationId String?
  ip            String?
  userAgent     String?
  createdAt     DateTime @default(now())

  @@index([entityType, entityId, createdAt])
  @@index([actorUserId, createdAt])
}

/// --------------------------------------------------
/// Captain short-form video library (30s trimmed clips)
/// --------------------------------------------------
model CaptainVideo {
  id            String   @id @default(cuid())
  ownerId       String
  originalUrl   String   // Uploaded 30s slice (or full if shorter)
  blobKey       String?  // Underlying blob storage key for deletion / normalization
  thumbnailUrl  String?
  thumbnailBlobKey String? // Blob key for persisted thumbnail
  trimStartSec  Float    @default(0)
  ready720pUrl  String?  // Optional normalized output
  normalizedBlobKey String? // Key for normalized 720p variant
  processStatus String   @default("queued") // queued | processing | ready | failed
  errorMessage  String?
  createdAt     DateTime @default(now())
  didFallback   Boolean  @default(false) // Whether client-side trim fell back to untrimmed media
  fallbackReason String? // Reason provided by client for fallback (parser failure, etc.)
  updatedAt     DateTime @updatedAt
  // Minimal future relations: could link to Charter if needed
  @@index([ownerId, processStatus])
  @@index([createdAt])
}
